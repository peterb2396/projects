package assignment1;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;


/**
 * Tests the ExpressionTree and it's features 
 * @author Peter Buonaiuto
 * @version 1.0
 */
public class Helper {
	
	/**
	 * Retrieves the path of the file containing info as a String
	 */
	private final static String path = Helper.class.getProtectionDomain().getCodeSource().getLocation().getPath() + Helper.class.getPackage().getName() + "/expressions";
	static ArrayList<ExpressionTree> trees = new ArrayList<ExpressionTree>();
	
	/**
	 * Handles the commencement of testing by calling methods that load 
	 * the info and traverse each tree
	 * @throws FileNotFoundException
	 */
	public static void start() throws FileNotFoundException {
		  
		  loadFile(); //Load contacts from file to test
		  traverse(); //Traverse and print each tree
	}

	/**
	 * Traverses each tree in each way, then prints the tree and tests it's equality 
	 * to all other trees.
	 */
	private static void traverse() {
		for (ExpressionTree tree: trees) {
		//For each tree...
			
			
			System.out.println("Traversing the binary tree generated by the "
					+ "\nFully parenthetic expression: "+tree.infix);
			//Inorder
			
			tree.list.clear();
			tree.inorder(tree.getRoot());
			System.out.println("");
			System.out.println("INORDER:");
			printTree(tree);
			
			//Preorder
			tree.list.clear();
			tree.preorder(tree.getRoot());
			System.out.println("");
			System.out.println("PREORDER:");
			setPrefix(tree);
			printTree(tree);
			
			//Postorder
			tree.list.clear();
			tree.postorder(tree.getRoot());
			System.out.println("");
			System.out.println("POSTORDER:");
			printTree(tree);
			
			System.out.println(tree);
			printCongruences(tree);
			System.out.println("-----------------------------------------------------------------");
		}
		
	}
	
	/**
	 * Helper method to print out the element of each node by using the Node's toString
	 * @param tree - the tree to print data of
	 */
	private static void printTree(ExpressionTree tree) {
		
		for(Node<?> node: tree.list) 
			System.out.print(node);
		System.out.println(""); 
		System.out.println("");
		
	}
	
	/**
	 * Prints index+1 of all trees congruent to the given tree
	 * @param tree - the tree for which to state congruence
	 */
	private static void printCongruences(ExpressionTree tree) {
		String congruences = "";
		ArrayList<Integer> congruentIndexes = getCongruences(tree);
		
		//Format the indexes into a readable manner with commas and non-zero indexing
		for (int i: congruentIndexes) {
			if (congruences.length() == 0) 
				congruences += (i+1);
			else
				congruences += ", "+(i+1);
		}
		//Switch on 0, 1, or more (default)
		if (congruentIndexes.size() == 0)
			System.out.println("This tree ("+(trees.indexOf(tree)+1) +") has no congruences.");
		else if (congruentIndexes.size() == 1)
			System.out.println("This tree ("+(trees.indexOf(tree)+1) +") is congruent to tree "+congruences);
		else
			System.out.println("This tree ("+(trees.indexOf(tree)+1) +") is congruent to trees "+congruences);
	}
		
	/**
	 * Determines which trees, if any, are congruent to a given tree by using 
	 * the ExpressionTree's equal method.
	 * @param tree - tree for which to investigate congruence
	 * @return ArrayList<Integer> of all indexes of congruent trees.
	 */
	private static ArrayList<Integer> getCongruences(ExpressionTree tree) {
		//Compares a given tree to each other one.
		ArrayList<Integer> congruentIndexes = new ArrayList<Integer>();
		
			for (ExpressionTree otherTree: trees) {
				//If we're not comparing a tree to itself...
				if (trees.indexOf(tree) != trees.indexOf(otherTree)) {
					if (tree.equals(otherTree)) {
						congruentIndexes.add(trees.indexOf(otherTree));
					}
				}
			}
			return congruentIndexes;
		}
	 
	/**
	 * Stores prefix string in tree class to allow for overridden toString() method to include data
	 * about the tree's prefix at any point. This must be done after traversal as a method for prefix
	 * conversion was NOT requested, but a prefix conversion was required in the ExpressionTree's print
	 * method. So we grab it while traversing and store it to satisfy this request.
	 * @param tree - the tree to set the prefix within
	 */
	private static void setPrefix(ExpressionTree tree) {
		String prefix = "";
		for(Node<?> node: tree.list)
			prefix+=node;
		tree.prefix = prefix;
			
	}
	
	/**
	 * Attempts to load the file on expressions 
	 * If successful, fill the arraylist of ExpressionTrees with a new tree for each given the
	 * infix expression from the file as a parameter.
	 * @throws FileNotFoundException
	 */
	private static void loadFile() throws FileNotFoundException{
		File expressionFile = new File(path);
		Scanner sc = new Scanner(expressionFile);

		while (sc.hasNextLine()) 
			trees.add(new ExpressionTree(sc.nextLine()));
		sc.close();
	}
	
}